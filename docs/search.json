[
  {
    "objectID": "Portfolio_WEB.html",
    "href": "Portfolio_WEB.html",
    "title": "Portfólio WEB de Iniciação Científica sobre órbitas",
    "section": "",
    "text": "A exploração do ambiente espacial, mais especificamente as órbitas terrestres, tem sido de suma importância e um dos maiores triúnfos da engenharia e física da atualidade. Desde os primeiros lançamentos de satélites, a previsão das trajetórias de objetos em órbita com alta precisão se tornou indispensável para a comunicação, GPS, pesquisas científicas e outros (BATE 1971). Nesse contexto, a Estação Espacial Internacional (International Space Station, ISS), literalmete um laboratório em constante queda livre, se torna objeto ideal de estudo para a demonstração das leis da mecânica clássica e o poder de previsão.\nDesta maneira, este Portfólio WEB apresenta uma proposta didática para o ensino das técnicas de simulção orbital utilizando a linguagem de programação Python, tomando como estudo de caso a trajetória da ISS em torno da Terra. O portfólio abordará os temas físicos como as descobertas de Tycho Brahe e Johann Kepler, a dedução da equação de Newton para o problema de 2 corpos, porém também passará por tópicos computacionais, como programação em python,métodos computacionais e métodos de integração numérica. O objetivo central é demonstrar como modelos matemáticos podem ser traduzidos em algoritmos, com capacidade de prever o comportamento de satélites em órbitas de baixa altitude (Low Earth Orbits, LEOs), com o intuito de passar todos os passos necessários para atingir o mesmo resultado do portfólio, e quando não for possível passar sugestões de referencias complementares. Através de uma abordagem prática, exploramos como as forças gravitacionais e outras variáveis moldam o movimentos dos objetos e como métodos de integração numérica, como Método de Euler e Runge Kutta, permitem estimar com alta precisão a posição e a velocidade da estação ao longo do tempo (VALLADO 2013; CURTIS 2013).\nA intenção desse trabalho é ser mais que apenas um repositório de códigos, é dar contextualização sobre a física por de trás dos algoritimos. Ao longo das seções serão discutidos temas como : Elementos Orbitais; Equações Diferenciais Ordinárias (EDOs); utilização de scripts em Python e bibliotecas como Numpy e Matplot.lib, para visualização 3D das órbitas; achatamento terrestre e coeficiente \\(J2\\); Arrasto Atmosférico e etc.\nDessa forma esse portfólio serve como uma ponte entre a física teórica e a experimentação computacional, ofertando um recurso interativo aos entusiastas que queiram aprofundar seus conhecimentos sobre dinâmica orbital."
  },
  {
    "objectID": "Portfolio_WEB.html#conhecimentos-adicionais-da-elipse",
    "href": "Portfolio_WEB.html#conhecimentos-adicionais-da-elipse",
    "title": "Portfólio WEB de Iniciação Científica sobre órbitas",
    "section": "4.1. Conhecimentos adicionais da elipse",
    "text": "4.1. Conhecimentos adicionais da elipse\n\n\\(a\\) = semieixo maior : Define a distância do centro da elipse até a maior extremidade.\n\\(b\\) = semieixo menor : Define a distância do centro da elipse até a menor extremidade, e pode ser calculado através de:\n\n\\[ a * \\sqrt{1 - e^2}  \\tag{4}\\]\n\n\\(e\\) = excentricidade da órbita: Define o quão achatada será a elipse.\nfoco = o foco da elipse. A elipse possui dois focos (\\(F_1\\) e \\(F_2\\)), que são pontos fixos no eixo maior, cuja a soma das distância de qualquer ponto (\\(P\\)) da elipse é constante e igual a \\(2a\\). O foco pode ser encontrado por:\n\n\\[ foco = a * e  \\tag{5}\\]"
  },
  {
    "objectID": "Portfolio_WEB.html#conceitos-adicionais-de-programação-para-o-primeiro-código",
    "href": "Portfolio_WEB.html#conceitos-adicionais-de-programação-para-o-primeiro-código",
    "title": "Portfólio WEB de Iniciação Científica sobre órbitas",
    "section": "4.2. Conceitos adicionais de programação para o primeiro código",
    "text": "4.2. Conceitos adicionais de programação para o primeiro código\nPara este primeiro código é interessante possuir uma noção básica de programação, porém não é necessário e qualquer um pode embarcar nesse desafio. É recomendado a utilização do google Collab para escrita dos códigos, ele é uma ferramenta dinâmica, de facil utilização, não requisita hardware pesado e pode ser acessado de forma gratuita no seguinte endereço: Google Colab.\nNo código iremos utilizar duas bibliotecas do Python: a Numpy, que é uma biblioteca fundamental para computação científica em Python, essencial para manipulação de grandes arrays e matrizes multidimensionais, ou seja, nos ajudará com manipulações matemáticas; a outra biblioteca que iremos usar é a Matplotlib, que nos dará as ferramentas necessárias para fazer os gráficos. A documentação das duas bibliotecas pode ser encontrada nos respectivos links: Biblioteca Numpy ; Biblioteca Matplotlib.\nEm questão de linguagem de programação utilizada para os códigos, será em sua totalidade apenas Python, logo não é necessário conhecimentos prévios de outras linguagens. A documentação da linguagem pode ser acessada através de: Python."
  },
  {
    "objectID": "Portfolio_WEB.html#primeira-simulação",
    "href": "Portfolio_WEB.html#primeira-simulação",
    "title": "Portfólio WEB de Iniciação Científica sobre órbitas",
    "section": "4.3. Primeira simulação",
    "text": "4.3. Primeira simulação\nAgora, seguindo o passo a passo comentado do código a seguir, é possível fazermos nossa primeira simulação em python, baseada na equação da elipse e fundamentada nas leis de Kepler.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 1. Configurações da Elipse (1ª Lei)\na = 5       # Comprimento da órbita\ne = 0.6     # Excentricidade, ou seja, o quanto a órbita é \"achatada\" (0 a 1)\nb = a * np.sqrt(1 - e**2)  # Largura da órbita\nfoco = a * e               # Distância do Sol até o centro\n\n# 2. Criar os pontos da linha da órbita\nt = np.linspace(0, 2 * np.pi, 100)\nx = a * np.cos(t) - foco   # Movemos a elipse para o Sol ficar no (0,0)\ny = b * np.sin(t)\n\n# 3. Desenhar o gráfico\nplt.figure(figsize=(8, 5))\n\n# Desenha a órbita e o Sol\nplt.plot(x, y, 'gray', label='Caminho do Planeta')\nplt.scatter(0, 0, color='orange', s=300, label='Sol') # Sol no foco\n\n# 4. Demonstrar a 2ª Lei (Velocidade)\n# Planeta no Periélio (Perto do Sol -&gt; Rápido)\nplt.scatter(a-foco, 0, color='red', s=100)\nplt.text(a-foco, 0.5, \"Rápido\", color='red', fontweight='bold')\n\n# Planeta no Afélio (Longe do Sol -&gt; Lento)\nplt.scatter(-a-foco, 0, color='blue', s=100)\nplt.text(-a-foco, 0.5, \"Lento\", color='blue', fontweight='bold')\n\n# Estética\nplt.title(\"Simulação Simplificada das Leis de Kepler\")\nplt.axhline(0, color='black', lw=0.5, ls='--')\nplt.axvline(0, color='black', lw=0.5, ls='--')\nplt.legend()\nplt.axis('equal')\nplt.show()"
  }
]